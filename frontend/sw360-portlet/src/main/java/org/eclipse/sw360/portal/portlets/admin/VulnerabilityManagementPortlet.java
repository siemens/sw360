/*
SPDX-FileCopyrightText: Â© 2022 Siemens AG
SPDX-License-Identifier: EPL-2.0
*/
package org.eclipse.sw360.portal.portlets.admin;

import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.portlet.PortletResponseUtil;
import org.eclipse.sw360.datahandler.thrift.vmcomponents.VMComponentService;
import org.eclipse.sw360.datahandler.thrift.vmcomponents.VMMatch;
import org.eclipse.sw360.datahandler.thrift.vmcomponents.VMProcessReporting;
import org.eclipse.sw360.exporter.VMMatchExporter;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.thrift.TException;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.RequestSummary;
import org.eclipse.sw360.datahandler.thrift.users.User;
import org.eclipse.sw360.portal.common.PortalConstants;
import org.eclipse.sw360.portal.portlets.Sw360Portlet;
import org.eclipse.sw360.portal.users.UserCacheHolder;

import javax.portlet.*;
import java.io.IOException;
import java.util.Collections;
import java.util.List;

import static org.eclipse.sw360.portal.common.PortalConstants.*;

/**
 * This portlet displays the process of the vulnerability management and the matches
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityManagementPortlet extends Sw360Portlet {

    private static final Logger log = LogManager.getLogger(VulnerabilityManagementPortlet.class);
    /**
     * Excel exporter
     */
    private final VMMatchExporter exporter = new VMMatchExporter();

    @Override
    public void doView(RenderRequest request, RenderResponse response) throws IOException, PortletException {
        // Proceed with page rendering
        prepareStandardView(request);
        super.doView(request, response);
    }

    private void prepareStandardView(RenderRequest request) throws IOException {
        List<VMProcessReporting> vmProcessList;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            User user = UserCacheHolder.getUserFromRequest(request);

            vmProcessList = vmClient.getAllProcesses(user);

        } catch (TException e) {
            log.error("Could not get Processes and Matches from backend ", e);
            vmProcessList = Collections.emptyList();
        }

        request.setAttribute(VM_PROCESS_LIST, vmProcessList);
    }

    @Override
    public void serveResource(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        String action = request.getParameter(ACTION);
        if (VM_SYNC_COMPONENTS.equals(action)) {
            syncVMComponents(request,response);
        } else if (EXPORT_TO_EXCEL.equals((action))) {
            exportExcel(request, response);
        } else if (VM_MATCH_ACCEPT.equals(action)){
            acceptMatch(request, response);
        } else if (VM_MATCH_DECLINE.equals(action)){
            declineMatch(request, response);
        } else if (VM_MATCH_GET_LIST.equals(action)){
            getMatches(request, response);
        } else if (VM_REVERSE_MATCH.equals(action)){
            triggerReverseMatch(request, response);
        }
    }

    private void renderMatchList(PortletRequest request, MimeResponse response, RequestStatus requestStatus, List<VMMatch> vmMatches) {
        JSONObject jsonObject = JSONFactoryUtil.createJSONObject();
        jsonObject.put("result", requestStatus.toString());
        jsonObject.put(VM_MATCH_LIST, serializeMatchList(vmMatches));
        try {
            writeJSON(request, response, jsonObject);
        } catch (IOException e) {
            log.error("Problem rendering RequestStatus", e);
        }
    }

    private JSONArray serializeMatchList(List<VMMatch> vmMatches){
        JSONArray array = JSONFactoryUtil.createJSONArray();
        if (vmMatches != null && vmMatches.size() > 0){
            for (VMMatch match: vmMatches) {
                JSONObject json = JSONFactoryUtil.createJSONObject();
                json.put(VMMatch._Fields.ID.getFieldName(), match.getId());
                json.put(VMMatch._Fields.COMPONENT_NAME.getFieldName(), match.getComponentName());
                json.put(VMMatch._Fields.RELEASE_ID.getFieldName(), match.getReleaseId());
                json.put(VMMatch._Fields.RELEASE_VERSION.getFieldName(), match.getReleaseVersion());
                json.put(VMMatch._Fields.RELEASE_CPE.getFieldName(), match.getReleaseCpe());
                json.put(VMMatch._Fields.RELEASE_SVM_ID.getFieldName(), match.getReleaseSvmId());
                json.put(VMMatch._Fields.VENDOR_NAME.getFieldName(), match.getVendorName());
                json.put(VMMatch._Fields.VM_COMPONENT_ID.getFieldName(), match.getVmComponentId());
                json.put(VMMatch._Fields.VM_COMPONENT_NAME.getFieldName(), match.getVmComponentName());
                json.put(VMMatch._Fields.VM_COMPONENT_VENDOR.getFieldName(), match.getVmComponentVendor());
                json.put(VMMatch._Fields.VM_COMPONENT_VERSION.getFieldName(), match.getVmComponentVersion());
                json.put(VMMatch._Fields.VM_COMPONENT_CPE.getFieldName(), match.getVmComponentCpe());
                json.put(VMMatch._Fields.VM_COMPONENT_VMID.getFieldName(), match.getVmComponentVmid());
                json.put(VMMatch._Fields.STATE.getFieldName(), match.getState() == null ? "UNKNOWN" : match.getState().name());
                json.put(VMMatch._Fields.MATCH_TYPES_UI.getFieldName(), match.getMatchTypesUI());
                array.put(json);
            }
        }
        return array;
    }

    private void getMatches(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        RequestStatus status = null;
        List<VMMatch> vmMatches;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            User user = UserCacheHolder.getUserFromRequest(request);
            String state = request.getParameter(PortalConstants.VM_MATCH_STATE);
            vmMatches = vmClient.getAllMatches(user);
            status = RequestStatus.SUCCESS;
        } catch (TException e) {
            log.error("Error in vmcomponent client", e);
            vmMatches = Collections.emptyList();
            status = RequestStatus.FAILURE;
        }
        renderMatchList(request, response, status, vmMatches);
    }

    private void acceptMatch(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        RequestSummary requestSummary = null;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            User user = UserCacheHolder.getUserFromRequest(request);
            String id = request.getParameter(PortalConstants.VM_MATCH_ID);
            requestSummary = vmClient.acceptMatch(user, id);
            renderRequestSummary(request, response, requestSummary);
        } catch (TException e) {
            log.error("Error in vmcomponent client", e);
            renderRequestSummary(request, response, new RequestSummary(RequestStatus.FAILURE));
        }
    }

    private void declineMatch(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        RequestSummary requestSummary = null;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            User user = UserCacheHolder.getUserFromRequest(request);
            String id = request.getParameter(PortalConstants.VM_MATCH_ID);
            requestSummary = vmClient.declineMatch(user, id);
            renderRequestSummary(request, response, requestSummary);
        } catch (TException e) {
            log.error("Error in vmcomponent client", e);
            renderRequestSummary(request, response, new RequestSummary(RequestStatus.FAILURE));
        }
    }

    private void syncVMComponents(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        RequestSummary requestSummary = null;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            requestSummary = vmClient.synchronizeComponents();

            serveRequestStatus(request, response, requestSummary.getRequestStatus(), "Problem triggering SVM Sync", log);
        } catch (TException e) {
            log.error("Error in vmcomponent client", e);
        }
    }

    private void exportExcel(ResourceRequest request, ResourceResponse response) {
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            User user = UserCacheHolder.getUserFromRequest(request);
            List<VMMatch> matches = vmClient.getAllMatches(user);

            PortletResponseUtil.sendFile(request, response, "Matches.xlsx", exporter.makeExcelExport(matches), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        } catch (IOException | TException e) {
            log.error("An error occured while generating the Excel export", e);
        }
    }

    private void triggerReverseMatch(ResourceRequest request, ResourceResponse response) throws IOException, PortletException {
        RequestSummary requestSummary = null;
        try {
            final VMComponentService.Iface vmClient = thriftClients.makeVMClient();
            requestSummary = vmClient.triggerReverseMatch();

            serveRequestStatus(request, response, requestSummary.getRequestStatus(), "Problem triggering Reverse Match", log);
        } catch (TException e) {
            log.error("Error in vmcomponent client", e);
        }
    }
}
